- [X] observational-memory
  + https://mastra.ai/blog/observational-memory
  - 자연어로 컨텍스트를 관리한다
  - 두블록을 가짐
  - 첫번째로 옵저베이션 블록을 가지며 맨 위에둬서 항상 프롬프트 캐싱이 일어나게 한다
  - 두번째 블록에는 채팅내용이 담기는데 30k 토큰 리밋(조절가능)을 치면 요약해서 옵저베이션 블록 뒤에 붙이도록함
  - 그럼에도 불구하고 40k 리밋을 치면 이때는 옵저베이션 블럭 자체를 GC 함, 불필요하다 생각되는 블락들을 제거하고 압축하는 과정이 일어남(캐싱 초기화)
  - 그렇게 계속 이어나가게됨
  - 옵저베이션 블럭은 date, referenced date, relative date 3 개의 중첩으로 표현
  - 🔴 중요. 🟡 아마 중요. 🟢 정보 블럭 3개로 나눠서 표현
```markdown
Date: 2026-01-15
- 🔴 12:10 User is building a Next.js app with Supabase auth, due in 1 week (meaning January 22nd 2026)
  - 🔴 12:10 App uses server components with client-side hydration
  - 🟡 12:12 User asked about middleware configuration for protected routes
  - 🔴 12:15 User stated the app name is "Acme Dashboard"
```
  - 관련 개발 문서
    + https://mastra.ai/docs/memory/observational-memory
  - 생각을 좀 더 해보면
    - 메모리를 3가지 타입으로 나누고있음
      - Working Memroy(이하 WM)
      - Semantic Recall(이하 SR)
      - Observational Memory(이하 OM)
    - WM 은 일반 채팅을할때그 전체 목록
    - SR 은 RAG를 사용할때와 같이 임베딩과 벡터 디비를 통한 검색 불러오기
    - OM은 이 둘을 함친듯이 얘기하고있지만 SR은 좀 성격이 다른거같고(session wide) 다만 세션전체를 OM을 기록하고 해당 기록을 불러올수있을 것 같다
    - 요약의 요약의 요약 느낌이며, 자연어가 주는 이점과 모델만 잇으면 된다는 점때문에 적절수준(절대다수의 일반 사용 예)의 컨텍스트 크기에서는 효과를 발휘할것
    - 아마도 [[../codex|codex]] 의 `/compact` 도 마찬가지일거라고 생각하나 자연어 포맷 및 프롬프팅으로 관련 스코어가 현재 기준 SoTA 를 가지고 있다 정도의 의미를 부여하면 될 것
