# 러스트 프로그래밍 공식 가이드
- https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=216867525
- 오탈자: https://jpub.tistory.com/1020

## 목차
- [X] CHAPTER 1 시작하기 1
  - [X] 1.1 설치하기 1
  - [X] 1.2 첫 번째 러스트 프로그램 작성하기 4
  - [X] 1.3 카고 알아보기 9

- [X] CHAPTER 2 숫자 맞히기 게임의 구현 15
  - [X] 2.1 새 프로젝트 셋업하기 16
  - [X] 2.2 플레이어가 예측한 값 처리하기 17
  - [X] 2.3 난수 생성하기 23
  - [X] 2.4 난수와 사용자의 입력 비교하기 28
  - [X] 2.5 반복문을 이용해 다중 입력 지원하기 32

- [X] CHAPTER 3 일반 프로그래밍 개념 39
  - [X] 3.1 변수와 가변성 40
  - [X] 3.2 데이터 타입 45
  - [X] 3.3 함수 53
  - [X] 3.4 주석 60
  - [X] 3.5 흐름 제어 61

--- 정리선 [[../rust]]

- [X] CHAPTER 4 소유권 73
  - [X] 4.1 소유권이란? 73
  - [X] 4.2 참조와 대여 86
  - [X] 4.3 슬라이스 타입 93

- [X] CHAPTER 5 구조체를 활용한 관련 데이터의 구조화 101
  - [X] 5.1 구조체 정의와 인스턴스 생성 102
  - [X] 5.2 구조체를 사용하는 예제 프로그램 107
  - [X] 5.3 메서드 문법 112

- [X] CHAPTER 6 열거자와 패턴 매칭 119
  - [X] 6.1 열거자 정의하기 120
  - [X] 6.2 match 흐름 제어 연산자 127
  - [X] 6.3 if let을 이용한 간결한 흐름 제어 133

- [X] CHAPTER 7 패키지, 크레이트, 모듈로 프로젝트 관리하기 137
  - [X] 7.1 패키지와 크레이트 138
  - [X] 7.2 모듈을 이용한 범위와 접근성 제어 140
  - [X] 7.3 경로를 이용해 모듈 트리의 아이템 참조하기 142
  - [X] 7.4 use 키워드로 경로를 범위로 가져오기 150
  - [X] 7.5 모듈을 다른 파일로 분리하기 157

- [X] CHAPTER 8 범용 컬렉션 161
  - [X] 8.1 벡터에 일련의 값 저장하기 162
  - [X] 8.2 String 타입에 UTF-8 형식의 텍스트 저장하기 168
  - [X] 8.3 키와 값을 저장하는 해시 맵 178

- [X] CHAPTER 9 에러 처리 185
  - [X] 9.1 panic! 매크로를 이용한 회복 불가능한 에러 처리 186
  - [X] 9.2 Result 타입으로 에러 처리하기 189
  - [X] 9.3 패닉에 빠질 것인가? 말 것인가? 200

- [X] CHAPTER 10 제네릭 타입, 트레이트 그리고 수명 207
  - [X] 10.1 함수로부터 중복 제거하기 208
  - [X] 10.2 제네릭 데이터 타입 211
  - [X] 10.3 트레이트: 공유 가능한 행위를 정의하는 방법 220
  - [X] 10.4 수명을 이용해 참조 유효성 검사하기 233
  - [X] 10.5 제네릭 타입 매개변수, 트레이트 경계, 그리고 수명 248

- [X] CHAPTER 11 자동화 테스트 작성하기 251
  - [X] 11.1 테스트의 작성 252
  - [X] 11.2 테스트 실행 제어하기 268
  - [X] 11.3 테스트의 조직화 274

- [X] CHAPTER 12 I/O 프로젝트: 명령줄 프로그램 작성하기 283
  - [X] 12.1 명령줄 인수 처리하기 284
  - [X] 12.2 파일 읽기 287
  - [X] 12.3 모듈화와 에러 처리 향상을 위한 리팩토링 289
  - [X] 12.4 테스트 주도 방법으로 라이브러리의 기능 개발하기 303
  - [X] 12.5 환경 변수 다루기 310
  - [X] 12.6 stderr을 이용해 에러 메시지 출력하기 316

- [X] CHAPTER 13 함수형 언어의 기능: 반복자와 클로저 321
  - [X] 13.1 클로저: 주변 환경을 캡처하는 익명 함수 322
  - [X] 13.2 반복자를 이용해 일련의 아이템 처리하기 337
  - [X] 13.3 입출력 프로젝트의 개선 346

- [X] CHAPTER 14 카고와 crates.io 353
  - [X] 14.1 릴리즈 프로필을 이용한 빌드 커스터마이징 354
  - [X] 14.2 crates.io 사이트에 크레이트 발행하기 355
  - [X] 14.3 카고 작업공간 367
  - [X] 14.4 cargo install 명령을 이용해 crates.io에서 바이너리 설치하기 374
  - [X] 14.5 사용자 정의 명령을 이용해 카고 확장하기 375

- [X] CHAPTER 15 스마트한 포인터 377
  - [X] 15.1 Box<T>를 이용해 힙 메모리의 데이터 참조하기 379
  - [X] 15.2 Deref 트레이트를 이용해 스마트 포인터를 참조처럼 취급하기 384
  - [X] 15.3 Drop 트레이트를 구현해서 메모리를 해제할 때 코드 실행하기 391
  - [X] 15.4 Rc<T>, 참조 카운터 스마트 포인터 395
  - [X] 15.5 RefCell<T> 타입과 내부 가변성 패턴 400
  - [X] 15.6 메모리 누수의 원인이 되는 순환 참조 410

- [X] CHAPTER 16 자신 있는 동시성 421
  - [X] 16.1 코드를 동시에 실행하기 위한 스레드 422
  - [X] 16.2 공유 상태 동시성 438
  - [X] 16.3 Sync와 Send 트레이트로 동시성 확장하기 446

- [X] CHAPTER 17 러스트의 객체지향 프로그래밍 기능 449
  - [X] 17.1 객체지향 언어의 특징 450
  - [X] 17.2 다른 타입의 값을 허용하는 트레이트 객체 454
  - [X] 17.3 객체지향 디자인 패턴 구현 462

- [X] CHAPTER 18 패턴과 매칭 477
  - [X] 18.1 패턴을 활용할 수 있는 위치 478
  - [X] 18.2 부인 가능성: 패턴이 일치할 수도 있고 그렇지 않을 수도 있는 경우 484
  - [X] 18.3 패턴 문법 486

- [X] CHAPTER 19 러스트의 고급 기능 505
  - [X] 19.1 안전하지 않은 러스트 506
  - [X] 19.2 고급 트레이트 517
  - [X] 19.3 고급 타입 시스템 529
  - [X] 19.4 고급 함수와 클로저 537
  - [X] 19.5 매크로 541

- [ ] CHAPTER 20 최종 프로젝트: 다중 스레드 웹서버 구축 555
  - [ ] 20.1 단일 스레드 웹서버 구현하기 556
  - [ ] 20.2 다중 스레드 서버로 전환하기 568
  - [ ] 20.3 우아한 종료와 해제 591

- [X] APPENDIX A 키워드 601
  - [X] 현재 사용 중인 키워드 601
  - [X] 향후에 사용하기 위해 예약한 키워드 603
  - [X] 원시 식별자 603

- [X] APPENDIX B 연산자와 심볼 605
  - [X] 연산자 605
  - [X] 비연산자 심볼 607

- [X] APPENDIX C 상속 가능한 트레이트 613
  - [X] 프로그래머용 출력을 위한 Debug 614
  - [X] 일치 비교를 위한 PartialEq와 Eq 614
  - [X] 순서를 비교하는 PartialOrd와 Ord 615
  - [X] 값을 복제하기 위한 Clone과 Copy 616
  - [X] 어떤 값을 고정된 크기의 값에 매핑하는 Hash 617
  - [X] 기본값을 제공하는 Default 617

- [X] APPENDIX D 유용한 개발 도구 619
  - [X] rustfmt를 이용한 자동 포매팅 619
  - [X] rustfix 도구로 코드 수정하기 620
  - [X] Clippy 린트 621
  - [X] 러스트 언어 서버를 이용한 IDE 통합 623

- [X] APPENDIX E 에디션 625

찾아보기 627

## link
- [[../rust]]
